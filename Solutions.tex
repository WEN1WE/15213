\documentclass{report}
\usepackage[utf8]{inputenc}
 
\usepackage{graphicx} %package to manage images
\usepackage[rightcaption]{sidecap}
\usepackage{wrapfig}
\usepackage{float}
 
\usepackage{listings}
\usepackage{color}
 
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
 
\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}
 
\lstset{style=mystyle}

\begin{document}

\chapter{A Tour of Computer Systems}

\chapter{Representing and Manipulating Information}

\section{Information Storage}
\paragraph{Solution to Problem } 2.1 \\
A: 0011 1001 1010 0111 1111 1000 \\
B: 0xC97B  \\
C: 1101 0101 1110 0100 1100  \\
D: 0x26E7B5  \\

\paragraph{Solution to  Problem } 2.2
\begin{center}
\begin{tabular}{ |c|c|c| } 
\hline
n & \(2^n\)(decimal) & \(2^n\)(hexadecimal) \\
\hline\hline
9 & 512 & 0x200 \\
\hline
19 & 524288 & 0x80000 \\
\hline
14 & 16384 & 0x4000 \\
\hline
16 & 65536 & 0x10000 \\
\hline
17 & 131072 & 0x20000 \\
\hline
5 & 32 & 0x20  \\
\hline
7 & 128 & 0x80 \\
\hline 
\end{tabular}
\end{center}

\paragraph{Solution to Problem} 2.3
\begin{center}
\begin{tabular}{ |c|c|c| } 
\hline
Decimal & Binary & Hexadecimal \\
\hline\hline
0 & 0000 0000 & 0x00 \\
\hline
167 & 1010 0111 & 0xA7 \\
\hline
62 &  0011 1110 & 0x3E \\
\hline
188 & 1011 1100 & 0xBC  \\
\hline
55 & 0011 0111 & 0x37  \\
\hline
136 & 1000 1000 & 0x88 \\
\hline
243 & 1111 0011 & 0xF3 \\
\hline
82 & 0101 0010 & 0x52 \\
\hline
172 & 1010 1100 & 0xAC \\
\hline
231 & 1110 0111 & 0xE7  \\
\hline
\end{tabular}
\end{center}

\paragraph{Solution to Problem} 2.3 \\
A: 0x5044  \\
B: 0x4FFC  \\ 
C: 0x507C  \\
D: 0xAE  \\

\paragraph{Code} 2-4

\begin{lstlisting}

#include <stdio.h>
typedef unsigned char *byte_pointer;

void show_bytes(byte_pointer start, size_t len) {
	size_t i;
	for (i = 0; i < len; i++)
		printf("%.2x", start[i]);
	printf("\n");
}

void show_int(int x) {
	show_bytes((byte_pointer)&x, sizeof(int));
}

void show_float(float x) {
	show_bytes((byte_pointer)&x, sizeof(float));
}

void show_pointer(void *x) {
	show_bytes((byte_pointer)&x, sizeof(void *));
}

void test_show_bytes(int val) {
	int ival = val;
	float fval = (float)ival;
	int *pval = &ival;
	show_int(ival);
	show_float(fval);
	show_pointer(pval);
}

int main() {
	test_show_bytes(12345);
	return 0;
}

\end{lstlisting}
\includegraphics[scale=0.4]{Solution/images/Code2_4.png}

\paragraph{Solution to Problem} 2.5 \\
A: Little endian:21 \hspace{10mm} Big endian:87 \\
B: Little endian:21 43 \hspace{6mm} Big endian:87 65 \\
C: Little endian:21 43 65 \hspace{1mm} Big endian 87 65 43

\paragraph{Solution to Problem} 2.6  \\
A: 0x00359141 : 00000000001 101011001000101000001 

0x4A564504 : \hspace{1mm} 010010100 101011001000101000001 00 \\
B: 21 \\
C: We find all bits of the integer embedded in the floating-point number, except for the most significant bit aving value 1.

\paragraph{Solution to Problem} 2.7 \\
61 62 63 64 65 66(strlen does not count the terminating null character.

\paragraph{Solution to Problem} 2.9 \\
A: white(black) yello(bule) magenta(green) cyan(red) \\
B: Cyan(011) Green(010) Blue(001)

\paragraph{Solution to Problem} 2.10
\begin{center}
\begin{tabular}{ |c|c|c| } 
\hline
Step & *x & *y \\
\hline\hline
Initially & a & b \\
\hline
Step 1 & a & a\textasciicircum b \\   
\hline  
Step 2 & b & a\textasciicircum b \\
\hline
Step 3 & b & a \\
\hline
\end{tabular}
\end{center}

\paragraph{Solution to Problem} 2.11 \\
A: Both first and last have value k. \\
B: In this case, x and y point to the same location, and a\textasciicircum a = 0 \\
C: In line 4, replace first $\leq$ last to  first $<$ last

\paragraph{Solution to Problem} 2.12 \\
A: x $\&$ 0xFF  \\
B: x\textasciicircum {\textasciitilde 0xFF} \\
C: x \textbar \hspace{1mm} 0xFF \\

\paragraph{Solution to Problem} 2.13 \\
\begin{lstlisting}
int bis(int x, int m) {
	return x | m;
}

int bic(int x, int m) {
	return x & (!m);
}

int bool_or(int x, int y) {
	int result = bis(x, y);
	return result;
}

int bool_xor(int x, int y) {
	int result = bis(bic(x, y), bic(y, x));
	return result;
}

\end{lstlisting}

\paragraph{Solution to Problem} 2.14 \\
\begin{center}
\begin{tabular}{ |c|c|c| } 
\hline
logical operators & bit level operations   \\
\hline\hline  
$\&\&$ & $\&$  \\
\hline  
\textbar \textbar & \textbar  \\
\hline
$!$  & \textasciitilde  \\
\hline
& \textasciicircum \\
\hline
\end{tabular}
\end{center}

\paragraph{Solution to Problem} 2.15 \\
\begin{lstlisting}
!(x ^ y)
\end{lstlisting}


\paragraph{Solution to Problem} 2.16 \\
\begin{center}
\begin{tabular}{ |c|c|c|c|c|c|c|c| }  
\hline
Hex & Binary & Binary & Hex & Binary & Hex & Binary & Hex  \\
\hline\hline
0xC3 & [11000011] &  [00011000] & 0x18 & [00110000] & 0x30 & [11110000] & 0xF0 \\
\hline
0x75 & [01110101] &  [10101000] & 0xA8 & [00011101] & 0x1D &[00011101] & 0x1D \\ 
\hline
0x87 & [10000111] &  [00111000] & 0x38 & [00100001] & 0x21 & [11100001] & 0xE1 \\
\hline
0x66 & [01100110] &  [00110000] & 0x30 & [00011001] & 0x19 & [00011001] & 0x19 \\
\hline
\end{tabular}
\end{center}

\paragraph{Solution to Problem} 2.17 \\

\begin{center}
\begin{tabular}{ |c|c|c|c| } 
\hline
0xE & [1110] & 14 & -2 \\
\hline
0x0 & [0000] & 0 & 0 \\
\hline
0x5 & [0101] & 5 & 5 \\
\hline
0x8 & [1000] & 8 & 8 \\
\hline
0xD & [1101] & 13 & -3 \\
\hline
0xF & [1111] & 15 & -1 \\
\hline
\end{tabular}
\end{center}

\paragraph{Solution to Problem} 2.19 \\
\begin{center}
\begin{tabular}{ |c|c|c| } 
\hline
x & $T2U_4(x)$ \\
\hline
-8 & 8 \\
-3 & 13 \\
-2 & 14 \\
-1 & 15 \\
0 & 0 \\
5 & 5 \\
\hline
\end{tabular}
\end{center}

\paragraph{Solution to Problem} 2.21 \\

\begin{center}
\begin{tabular}{ |c|c|c| } 
\hline
Expression & Type & Evaluation \\
\hline
& Unsighed & 1 \\
\hline
& Signed & 1 \\
\hline
& Unsighed & 0 \\
\hline
& Sighed & 1 \\
\hline
& Unsigned & 1 \\
\hline
\end{tabular}
\end{center}

\paragraph{Solution to Problem} 2.23 \\
\begin{center}
\begin{tabular}{ |c|c|c| } 
\hline
w & fun1(w) & fun2(w) \\
\hline
& 0x00000076 & 0x00000076 \\
\hline
& 0x00000021 & 0x00000021 \\
\hline
& 0x000000C9 & 0xFFFFFFC9 \\
\hline
& 0x00000087 & 0xFFFFFF87 \\
\hline
\end{tabular}
\end{center}

\paragraph{Solution to Problem} 2.25 \\
Since parameter length is unsigned, the computation 0 - 1 performed using unsigned arithmetic, so the result is then UMax.
\begin{lstlisting}
// line 6  
for (i = 0; i < length; i++)
\end{lstlisting}

\paragraph{Solution to Problem} 2.26 \\
A: The function will incorrectly return 1 when s is shorter than t.
B: Since strlen is defined to yield an unsigned result, the difference and the comparison are both computed using unsigned arithmetic.
C:
\begin{lstlisting}
return strlen(s) > strlen(t);
\end{lstlisting}

\paragraph{Solution to Problem} 2.27 \\
\begin{lstlisting}
return  x + y > x
\end{lstlisting}

\paragraph{Solution to Problem} 2.28 \\
\begin{center}
\begin{tabular}{ |c|c|c|c| } 
\hline
\multicolumn{2}{|c|}{x}  &   \multicolumn{2}{|c|}{$-^u_4$x}  \\  \hline
Hex & Decimal & Decimal & Hex  \\   \hline 
0 & 0 & 0 & 0 \\
5 & 5 & 11& B  \\ 
8 & 8 & 8 & 8 \\
D & 13 & 3 & 3 \\
F & 15 & 1 & 1 \\ \hline
\end{tabular}
\end{center}

\paragraph{Solution to Problem} 2.30 \\


\begin{lstlisting}
int tadd_ok(int x, int y) {
    int sum = x + y;
    int neg_over = x < 0 && y < 0 && sum >= 0;
    int pos_over = x >= 0 && y >= 0 && sum < 0;
    return !neg_over && !pos_over;
}
\end{lstlisting}

\paragraph{Solution to Problem} 2.31 \\
The expression $(x+y)-x$ will evaluate to y regardless of whether or not the addition overflows.

\paragraph{Solution to Problem} 2.32 \\
When y is TMin, we will have -y also equal to TMin.


\paragraph{Solution to Problem} 2.33 \\
\begin{center}
\begin{tabular}{ |c|c|c|c| } 
\hline
\multicolumn{2}{|c|}{x}  &   \multicolumn{2}{|c|}{$-^t_4$x}  \\  \hline
Hex & Decimal & Decimal & Hex  \\   \hline 
0 & 0 & 0 & 0 \\
5 & 5 & -5 & B  \\ 
8 & -8 & -8 & 8 \\
D & -3 & 3 & 3 \\
F & -1 & 1 & 1 \\ \hline
\end{tabular}
\end{center}

\paragraph{Solution to Problem} 2.35 \\
1: x,y can be written as a 2w-bit two's-complement number.Let u denote the unsigned number represented by the lower w bits, and v denote the two's-complement number represented by the upper w bits. \\
$x * y = v2^w + u$ \\
$u = p + p_(w-1)2^w$ \\
let $t = v + p_(w-1)$
so $x * y = p + t2^w$ \\
When $t = 0$, we have $x * y = p$; the multiplication does not overflow.When $t \neq 0$ ,we have $x * y \neq p$;the multiplication does overflow.



\paragraph{Solution to Problem} 2.36 \\


\begin{lstlisting}
int tmult_ok(int x, int y) {
    int64_t pll = (int64_t) x*y
    
    return pll == (int) pll;
}
\end{lstlisting}

\paragraph{Solution to Problem} 2.38 \\
We can compute multiples 1,2,3,4,5,8,9

\paragraph{Solution to Problem} 2.39 \\
The expression simply becomes $-(x\ll m)$

\paragraph{Solution to Problem} 2.40 \\
\begin{center}
\begin{tabular}{ |c|c|c|c| } 
\hline
K & shifts & Add/Subs & Expression \\ \hline
6 & 2 & 1 & $(x \ll 2) + (x \ll 1)$ \\
31 & 1 & 1 & $(x \ll 5) - x$  \\
-6 & 2 & 1 & $(x \ll 1) - (x \ll 3)$  \\
55 & 2 & 2 & $(x \ll 6) - (x \ll 3)$  \\ \hline
\end{tabular}
\end{center}

\paragraph{Solution to Problem} 2.41 \\
Assuming that addition and subtraction have the same performance, the rule is to choose form A when $n = m$, either form when $n = m + 1$, and form B, when $n > m + 1$

\paragraph{Solution to Problem} 2.42 \\
\begin{lstlisting}
int div16(int x) {
    int bias = (x >> 31) & 0xF;
    return (x + bias) >> 4;
}
\end{lstlisting}


\paragraph{Solution to Problem} 2.43 \\
M is 31 and N is 8.

\paragraph{Solution to Problem} 2.44 \\
A: False. Let x be -2147483648($TMin_32$). \\
B: True \\
C: False. Let x be 65535. \\
D: True \\
E: False. Let x be $-2^{31}$
F: True. Two's-complement and unsigned addition have the same bit-level behavior, and thet are commutative. \\
G: True. \textasciitilde y = -y - 1

\paragraph{Solution to Problem} 2.46 \\
A: 0.0000 0000 0000 0000 0000 000 1100[1100]...

\paragraph{Solution to Problem} 2.47 \\
\begin{center}
\begin{tabular}{ |c|c|c|c|c|c|c|c|c| } 
\hline
 Bits & e & E & $2^E$ & f & M & $2^E x M$ & V & Decimal \\
0 00 00 & 0 & 0 & 1 & 0/4 & 0/4 & 0/4 & 0 & 0.0 \\
0 00 01 & 0 & 0 & 1 & 1/4 & 1/4 & 1/4 & 1/4 & 0.25 \\
0 00 10 & 0 & 0 & 1 & 2/4 & 2/4 & 2/4 & 2/4 & 0.5 \\
0 00 11 & 0 & 0 & 1 & 3/4 & 3/4 & 3/4 & 3/4 & 0.75 \\
0 01 00 & 1 & 0 & 1 & 0/4 & 4/4 & 4/4 & 1 & 1.1 \\
0 01 01 & 1 & 0 & 1 & 1/4 & 5/4 & 5/4 & 5/4 & 1.25 \\
0 01 10 & 1 & 0 & 1 & 2/4 & 6/4 & 6/4 & 3/2 & 1.5 \\
0 01 11 & 1 & 0 & 1 & 3/4 & 7/4 & 7/4 & 7/4 & 1.75 \\
0 10 00 & 2 & 1 & 2 & 0/4 & 4/4 & 8/4 & 2 & 2.0 \\
0 10 01 & 2 & 1 & 2 & 1/4 & 5/4 & 10/4 & 5/2 & 2.5 \\
0 10 10 & 2 & 1 & 2 & 2/4 & 6/4 & 12/4 & 3 & 3.0 \\
0 10 11 & 2 & 1 & 2 & 3/4 & 7/4 & 14/4 & 7/2 & 3.5 \\
\hline
\end{tabular}
\end{center}


\paragraph{Solution to Problem} 2.49 \\
A: The number has binary representation 1, followed by n zeros, followed by1, giving value $2^{n+1} + 1$. \\
B: When n = 23, the value is $2^{24} + 1 = 16777217$

\paragraph{Solution to Problem} 2.50 \\
A: 10.0
B: 10.1
C: 11.0
D: 11.0

\paragraph{Solution to Problem} 2.51 \\
\begin{center}
\begin{tabular}{ |c|c|c|c| } 
\hline
\multicolumn{2}{|c|}{Format A}  &   \multicolumn{2}{|c|}{Format B}  \\  
\hline
Bits & Value & Bits & Value  \\ 
\hline
011 0000 & 1 & 0111 000 & 1 \\
101 1110 & 15/2 & 1001 111 & 15/2 \\
010 1001 & 25/32 & 0110 100 & 3/4 \\
110 1111 & 31/2 & 1011 000 & 16 \\
000 0001 & 1/64 & 0001 000 & 1/64 \\
\hline
\end{tabular}
\end{center}





\end{document}
